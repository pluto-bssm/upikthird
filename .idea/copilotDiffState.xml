<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/question/[id]/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/question/[id]/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import React from &quot;react&quot;;&#10;import { useRouter, useParams } from &quot;next/navigation&quot;;&#10;import styled from &quot;@emotion/styled&quot;;&#10;import Header from &quot;@/components/common/header&quot;;&#10;import NavigationBar from &quot;@/components/common/navigationbar&quot;;&#10;import color from &quot;@/packages/design-system/src/color&quot;;&#10;import { useQuestionDetail, useQuestionComments } from &quot;@/hooks/useBoard&quot;;&#10;import * as boardApi from &quot;@/services/board/api&quot;;&#10;&#10;const QuestionDetailPage = () =&gt; {&#10;  const router = useRouter();&#10;  const params = useParams();&#10;  const boardId = Array.isArray(params?.id) ? params.id[0] : params?.id;&#10;&#10;  const { question, loading: questionLoading } = useQuestionDetail(&#10;    boardId as string,&#10;  );&#10;  const { comments, loading: commentsLoading } = useQuestionComments(&#10;    boardId as string,&#10;    { page: 0, size: 10 },&#10;  );&#10;&#10;  const [comment, setComment] = React.useState(&quot;&quot;);&#10;  const [submitting, setSubmitting] = React.useState(false);&#10;  const [replyingTo, setReplyingTo] = React.useState&lt;string | null&gt;(null);&#10;  const [replyContent, setReplyContent] = React.useState(&quot;&quot;);&#10;&#10;  const handleReportClick = () =&gt; {&#10;    router.push(`/question/${boardId}/report`);&#10;  };&#10;&#10;  const handleReplyClick = (commentId: string) =&gt; {&#10;    setReplyingTo(replyingTo === commentId ? null : commentId);&#10;    setReplyContent(&quot;&quot;);&#10;  };&#10;&#10;  const handleCommentSubmit = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (!comment.trim()) return;&#10;&#10;    try {&#10;      setSubmitting(true);&#10;      await boardApi.createComment({&#10;        boardId: boardId as string,&#10;        content: comment,&#10;      });&#10;      setComment(&quot;&quot;);&#10;    } catch (error) {&#10;    } finally {&#10;      setSubmitting(false);&#10;    }&#10;  };&#10;&#10;  const handleReplySubmit = async (&#10;    e: React.FormEvent,&#10;    parentCommentId: string,&#10;  ) =&gt; {&#10;    e.preventDefault();&#10;    if (!replyContent.trim()) return;&#10;&#10;    try {&#10;      setSubmitting(true);&#10;      await boardApi.createComment({&#10;        boardId: boardId as string,&#10;        content: replyContent,&#10;        parentId: parentCommentId,&#10;      });&#10;      setReplyContent(&quot;&quot;);&#10;      setReplyingTo(null);&#10;    } catch (error) {&#10;    } finally {&#10;      setSubmitting(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;StyledPage&gt;&#10;      &lt;Header types=&quot;report and close&quot; text=&quot;&quot; onClose={handleReportClick} /&gt;&#10;      &lt;Container&gt;&#10;        {questionLoading ? (&#10;          &lt;LoadingSection&gt;로딩 중...&lt;/LoadingSection&gt;&#10;        ) : question ? (&#10;          &lt;&gt;&#10;            &lt;Section&gt;&#10;              &lt;Title&gt;{question.title}&lt;/Title&gt;&#10;              &lt;MetaInfo&gt;&#10;                &lt;MetaItem&gt;{question.author?.name || &quot;작성자 미상&quot;}&lt;/MetaItem&gt;&#10;                &lt;MetaItem&gt;&#10;                  {new Date(question.createdAt).toLocaleString(&quot;ko-KR&quot;)}&#10;                &lt;/MetaItem&gt;&#10;                &lt;BookmarkBox&gt;&#10;                  &lt;BookmarkText&gt;{question.likes}&lt;/BookmarkText&gt;&#10;                &lt;/BookmarkBox&gt;&#10;              &lt;/MetaInfo&gt;&#10;            &lt;/Section&gt;&#10;&#10;            &lt;Divider /&gt;&#10;&#10;            &lt;ContentSection&gt;&#10;              &lt;Content&gt;{question.content}&lt;/Content&gt;&#10;            &lt;/ContentSection&gt;&#10;          &lt;/&gt;&#10;        ) : (&#10;          &lt;ErrorSection&gt;질문을 찾을 수 없습니다.&lt;/ErrorSection&gt;&#10;        )}&#10;&#10;        &lt;Divider /&gt;&#10;&#10;        &lt;CommentsSection&gt;&#10;          &lt;CommentCount&gt;댓글 {comments?.totalElements || 0}&lt;/CommentCount&gt;&#10;          {commentsLoading ? (&#10;            &lt;LoadingText&gt;댓글 로딩 중...&lt;/LoadingText&gt;&#10;          ) : comments?.content &amp;&amp; comments.content.length &gt; 0 ? (&#10;            comments.content.map((comment) =&gt; (&#10;              &lt;React.Fragment key={comment.id}&gt;&#10;                &lt;CommentItemWrapper isReply={false}&gt;&#10;                  &lt;CommentBox&gt;&#10;                    &lt;CommentHeader&gt;&#10;                      &lt;AuthorName&gt;&#10;                        {comment.author?.name || &quot;작성자 미상&quot;}&#10;                      &lt;/AuthorName&gt;&#10;                    &lt;/CommentHeader&gt;&#10;                    &lt;CommentContent&gt;{comment.content}&lt;/CommentContent&gt;&#10;                    &lt;CommentFooter&gt;&#10;                      &lt;FooterItem&gt;&#10;                        {new Date(comment.createdAt).toLocaleString(&quot;ko-KR&quot;)}&#10;                      &lt;/FooterItem&gt;&#10;                      &lt;FooterReportItem&#10;                        onClick={() =&gt;&#10;                          router.push(&#10;                            `/question/${boardId}/comment-report?commentId=${comment.id}`,&#10;                          )&#10;                        }&#10;                      &gt;&#10;                        신고하기&#10;                      &lt;/FooterReportItem&gt;&#10;                      &lt;FooterItem onClick={() =&gt; handleReplyClick(comment.id)}&gt;&#10;                        답글쓰기&#10;                      &lt;/FooterItem&gt;&#10;                    &lt;/CommentFooter&gt;&#10;                  &lt;/CommentBox&gt;&#10;                &lt;/CommentItemWrapper&gt;&#10;&#10;                {replyingTo === comment.id &amp;&amp; (&#10;                  &lt;ReplyInputWrapper&gt;&#10;                    &lt;ReplyInputBox&gt;&#10;                      &lt;ReplyInputField&#10;                        placeholder=&quot;답글을 입력해주세요&quot;&#10;                        value={replyContent}&#10;                        onChange={(e) =&gt; setReplyContent(e.target.value)}&#10;                      /&gt;&#10;                      &lt;ReplySubmitButton&#10;                        onClick={(e) =&gt; handleReplySubmit(e, comment.id)}&#10;                        disabled={submitting}&#10;                      &gt;&#10;                        등록&#10;                      &lt;/ReplySubmitButton&gt;&#10;                    &lt;/ReplyInputBox&gt;&#10;                  &lt;/ReplyInputWrapper&gt;&#10;                )}&#10;&#10;                {comment.replies &amp;&amp;&#10;                  comment.replies.length &gt; 0 &amp;&amp;&#10;                  comment.replies.map((reply) =&gt; (&#10;                    &lt;CommentItemWrapper key={reply.id} isReply={true}&gt;&#10;                      &lt;CommentBox&gt;&#10;                        &lt;CommentHeader&gt;&#10;                          &lt;AuthorName&gt;&#10;                            {reply.author?.name || &quot;작성자 미상&quot;}&#10;                          &lt;/AuthorName&gt;&#10;                        &lt;/CommentHeader&gt;&#10;                        &lt;CommentContent&gt;{reply.content}&lt;/CommentContent&gt;&#10;                        &lt;CommentFooter&gt;&#10;                          &lt;FooterItem&gt;&#10;                            {new Date(reply.createdAt).toLocaleString(&quot;ko-KR&quot;)}&#10;                          &lt;/FooterItem&gt;&#10;                          &lt;FooterReportItem&#10;                            onClick={() =&gt;&#10;                              router.push(&#10;                                `/question/${boardId}/comment-report?commentId=${reply.id}`,&#10;                              )&#10;                            }&#10;                          &gt;&#10;                            신고하기&#10;                          &lt;/FooterReportItem&gt;&#10;                        &lt;/CommentFooter&gt;&#10;                      &lt;/CommentBox&gt;&#10;                    &lt;/CommentItemWrapper&gt;&#10;                  ))}&#10;              &lt;/React.Fragment&gt;&#10;            ))&#10;          ) : (&#10;            &lt;NoCommentText&gt;댓글이 없습니다.&lt;/NoCommentText&gt;&#10;          )}&#10;&#10;          &lt;CommentInputBox&gt;&#10;            &lt;CommentInputField&#10;              placeholder=&quot;댓글을 입력해주세요&quot;&#10;              value={comment}&#10;              onChange={(e) =&gt; setComment(e.target.value)}&#10;            /&gt;&#10;            &lt;CommentSubmitButton&#10;              onClick={handleCommentSubmit}&#10;              disabled={submitting}&#10;            &gt;&#10;              등록&#10;            &lt;/CommentSubmitButton&gt;&#10;          &lt;/CommentInputBox&gt;&#10;        &lt;/CommentsSection&gt;&#10;      &lt;/Container&gt;&#10;&#10;      &lt;NavigationBar /&gt;&#10;    &lt;/StyledPage&gt;&#10;  );&#10;};&#10;&#10;export default QuestionDetailPage;&#10;&#10;const StyledPage = styled.div`&#10;  width: 100%;&#10;  max-width: 600px;&#10;  margin: 0 auto;&#10;  background-color: ${color.white};&#10;  min-height: 100vh;&#10;  padding-top: 80px;&#10;  padding-bottom: 80px;&#10;  display: flex;&#10;  flex-direction: column;&#10;  position: relative;&#10;`;&#10;&#10;const Container = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  width: 100%;&#10;  flex: 1;&#10;`;&#10;&#10;const Section = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;  padding: 20px;&#10;`;&#10;&#10;const Title = styled.h1`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 22px;&#10;  font-weight: 700;&#10;  color: ${color.black};&#10;  line-height: 1;&#10;  margin: 0;&#10;  word-break: break-word;&#10;`;&#10;&#10;const MetaInfo = styled.div`&#10;  display: flex;&#10;  gap: 6px;&#10;  align-items: center;&#10;  flex-wrap: wrap;&#10;`;&#10;&#10;const MetaItem = styled.span`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.gray600};&#10;  white-space: nowrap;&#10;&#10;  &amp;:not(:last-child)::after {&#10;    content: &quot;&quot;;&#10;    width: 1px;&#10;    height: 10px;&#10;    background-color: ${color.gray600};&#10;    margin-left: 6px;&#10;  }&#10;`;&#10;&#10;const BookmarkBox = styled.div`&#10;  display: flex;&#10;  gap: 2px;&#10;  align-items: center;&#10;  margin-left: 6px;&#10;`;&#10;&#10;const BookmarkText = styled.span`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.gray600};&#10;`;&#10;&#10;const Divider = styled.div`&#10;  height: 1px;&#10;  background-color: ${color.gray200};&#10;  width: 100%;&#10;`;&#10;&#10;const ContentSection = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;  padding: 20px;&#10;`;&#10;&#10;const Content = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 400;&#10;  color: ${color.gray700};&#10;  line-height: 24px;&#10;  margin: 0;&#10;  word-break: break-word;&#10;  white-space: pre-wrap;&#10;`;&#10;&#10;const CommentsSection = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  width: 100%;&#10;`;&#10;&#10;const CommentCount = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.gray600};&#10;  line-height: 1;&#10;  margin: 0;&#10;  padding: 20px;&#10;  padding-bottom: 0;&#10;`;&#10;&#10;const CommentItemWrapper = styled.div&lt;{ isReply?: boolean }&gt;`&#10;  display: flex;&#10;  gap: 10px;&#10;  padding: 20px;&#10;  padding-left: ${(props) =&gt; (props.isReply ? &quot;50px&quot; : &quot;20px&quot;)};&#10;  border-bottom: 1px solid ${color.gray100};&#10;`;&#10;&#10;const CommentBox = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;  flex: 1;&#10;  padding: 20px;&#10;`;&#10;&#10;const CommentHeader = styled.div`&#10;  display: flex;&#10;  gap: 6px;&#10;  align-items: center;&#10;`;&#10;&#10;const AuthorName = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.black};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const CommentContent = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${color.black};&#10;  line-height: 1;&#10;  margin: 0;&#10;  word-break: break-word;&#10;  white-space: normal;&#10;`;&#10;&#10;const CommentFooter = styled.div`&#10;  display: flex;&#10;  gap: 6px;&#10;  align-items: center;&#10;  justify-content: space-between;&#10;`;&#10;&#10;const FooterItem = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 10px;&#10;  font-weight: 400;&#10;  color: ${color.gray300};&#10;  line-height: 1;&#10;  margin: 0;&#10;  white-space: nowrap;&#10;&#10;  &amp;:not(:last-child)::after {&#10;    content: &quot;&quot;;&#10;    width: 1px;&#10;    height: 10px;&#10;    background-color: ${color.gray300};&#10;    margin-left: 6px;&#10;  }&#10;`;&#10;&#10;const SubmitButtonContainer = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  margin-left: auto;&#10;`;&#10;&#10;const SubmitButton = styled.button`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 12px;&#10;  font-weight: 400;&#10;  color: ${color.primary};&#10;  background: none;&#10;  border: none;&#10;  cursor: pointer;&#10;  padding: 0;&#10;`;&#10;&#10;const CommentInputBox = styled.div`&#10;  display: flex;&#10;  gap: 10px;&#10;  align-items: center;&#10;  padding: 20px;&#10;  border-top: 1px solid ${color.gray100};&#10;`;&#10;&#10;const CommentInputField = styled.textarea`&#10;  flex: 1;&#10;  background: none;&#10;  border: none;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 13px;&#10;  font-weight: 400;&#10;  color: ${color.black};&#10;  outline: none;&#10;  resize: none;&#10;  min-height: 40px;&#10;&#10;  &amp;::placeholder {&#10;    color: ${color.gray500};&#10;  }&#10;`;&#10;&#10;const FooterReportItem = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 10px;&#10;  font-weight: 400;&#10;  color: ${color.primary};&#10;  line-height: 1;&#10;  margin: 0;&#10;  white-space: nowrap;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.8;&#10;  }&#10;&#10;  &amp;::before {&#10;    content: &quot;&quot;;&#10;    width: 1px;&#10;    height: 10px;&#10;    background-color: ${color.gray300};&#10;    margin-right: 6px;&#10;    display: inline-block;&#10;  }&#10;&#10;  &amp;::after {&#10;    content: &quot;&quot;;&#10;    width: 1px;&#10;    height: 10px;&#10;    background-color: ${color.gray300};&#10;    margin-left: 6px;&#10;    display: inline-block;&#10;  }&#10;`;&#10;&#10;const ModalOverlay = styled.div`&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background-color: rgba(0, 0, 0, 0.5);&#10;  z-index: 999;&#10;`;&#10;&#10;const ModalContainer = styled.div`&#10;  position: fixed;&#10;  top: 50%;&#10;  left: 50%;&#10;  transform: translate(-50%, -50%);&#10;  z-index: 1000;&#10;  max-height: 90vh;&#10;  overflow-y: auto;&#10;  width: 90vw;&#10;  max-width: 400px;&#10;`;&#10;&#10;const ModalContent = styled.div`&#10;  background-color: ${color.white};&#10;  border: 1px solid ${color.gray200};&#10;  border-radius: 24px;&#10;  padding: 32px;&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 32px;&#10;`;&#10;&#10;const ModalTextContainer = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;`;&#10;&#10;const ModalSubtitle = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.gray700};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const ModalTitle = styled.h2`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 22px;&#10;  font-weight: 700;&#10;  color: ${color.black};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const ModalReasonSection = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;`;&#10;&#10;const ModalDetailSection = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;`;&#10;&#10;const LabelWithRequired = styled.div`&#10;  display: flex;&#10;  gap: 4px;&#10;  align-items: center;&#10;`;&#10;&#10;const Label = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${color.gray700};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const RequiredMark = styled.span`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: #e71d36;&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const ReasonList = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;`;&#10;&#10;const ReasonButton = styled.button&lt;{ isSelected: boolean }&gt;`&#10;  border: 1px solid&#10;    ${(props) =&gt; (props.isSelected ? color.primary : color.gray100)};&#10;  border-radius: 16px;&#10;  padding: 19px 20px;&#10;  background-color: ${(props) =&gt;&#10;    props.isSelected ? color.primary : color.white};&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${(props) =&gt; (props.isSelected ? color.white : color.gray600)};&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;  text-align: left;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.8;&#10;  }&#10;`;&#10;&#10;const DetailTextarea = styled.textarea`&#10;  border: 1px solid ${color.gray100};&#10;  border-radius: 16px;&#10;  padding: 20px;&#10;  min-height: 120px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 12px;&#10;  font-weight: 400;&#10;  color: ${color.black};&#10;  background-color: ${color.white};&#10;  resize: none;&#10;  outline: none;&#10;&#10;  &amp;::placeholder {&#10;    color: ${color.gray300};&#10;  }&#10;`;&#10;&#10;const CharCount = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 13px;&#10;  font-weight: 400;&#10;  color: ${color.gray300};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const ModalButtonContainer = styled.div`&#10;  display: flex;&#10;  gap: 12px;&#10;  align-items: center;&#10;  justify-content: center;&#10;  width: 100%;&#10;`;&#10;&#10;const ModalCancelButton = styled.button`&#10;  flex: 1;&#10;  background-color: ${color.white};&#10;  border: 1px solid ${color.gray100};&#10;  border-radius: 100px;&#10;  padding: 12px 20px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${color.black};&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.8;&#10;  }&#10;`;&#10;&#10;const ModalConfirmButton = styled.button`&#10;  flex: 1;&#10;  background-color: ${(props) =&gt;&#10;    props.disabled ? color.gray200 : color.primary};&#10;  border: none;&#10;  border-radius: 100px;&#10;  padding: 12px 20px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${color.white};&#10;  cursor: ${(props) =&gt; (props.disabled ? &quot;not-allowed&quot; : &quot;pointer&quot;)};&#10;  transition: all 0.2s ease;&#10;`;&#10;&#10;const LoadingText = styled.p`&#10;  text-align: center;&#10;  font-size: 14px;&#10;  color: ${color.gray600};&#10;  padding: 20px;&#10;  margin: 0;&#10;`;&#10;&#10;const NoCommentText = styled.p`&#10;  text-align: center;&#10;  font-size: 14px;&#10;  color: ${color.gray600};&#10;  padding: 40px 20px;&#10;  margin: 0;&#10;`;&#10;&#10;const CommentSubmitButton = styled.button`&#10;  background-color: ${(props) =&gt;&#10;    props.disabled ? color.gray200 : color.primary};&#10;  border: none;&#10;  border-radius: 6px;&#10;  padding: 10px 16px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 600;&#10;  color: ${color.white};&#10;  cursor: ${(props) =&gt; (props.disabled ? &quot;not-allowed&quot; : &quot;pointer&quot;)};&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.9;&#10;  }&#10;`;&#10;&#10;const LoadingSection = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  padding: 40px 20px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  color: ${color.gray600};&#10;`;&#10;&#10;const ErrorSection = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  padding: 40px 20px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  color: ${color.gray600};&#10;`;&#10;&#10;const ReplyInputWrapper = styled.div`&#10;  padding: 0 20px 16px 40px;&#10;`;&#10;&#10;const ReplyInputBox = styled.div`&#10;  display: flex;&#10;  gap: 8px;&#10;  width: 100%;&#10;`;&#10;&#10;const ReplyInputField = styled.input`&#10;  flex: 1;&#10;  border: 1px solid ${color.gray200};&#10;  border-radius: 6px;&#10;  padding: 10px 12px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.black};&#10;  background-color: ${color.white};&#10;  outline: none;&#10;&#10;  &amp;::placeholder {&#10;    color: ${color.gray300};&#10;  }&#10;&#10;  &amp;:focus {&#10;    border-color: ${color.primary};&#10;  }&#10;`;&#10;&#10;const ReplySubmitButton = styled.button`&#10;  background-color: ${(props) =&gt;&#10;    props.disabled ? color.gray200 : color.primary};&#10;  border: none;&#10;  border-radius: 6px;&#10;  padding: 10px 16px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 600;&#10;  color: ${color.white};&#10;  cursor: ${(props) =&gt; (props.disabled ? &quot;not-allowed&quot; : &quot;pointer&quot;)};&#10;  transition: all 0.2s ease;&#10;  white-space: nowrap;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.9;&#10;  }&#10;`;&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import React from &quot;react&quot;;&#10;import { useRouter, useParams } from &quot;next/navigation&quot;;&#10;import styled from &quot;@emotion/styled&quot;;&#10;import Header from &quot;@/components/common/header&quot;;&#10;import NavigationBar from &quot;@/components/common/navigationbar&quot;;&#10;import color from &quot;@/packages/design-system/src/color&quot;;&#10;import { useQuestionDetail, useQuestionComments } from &quot;@/hooks/useBoard&quot;;&#10;import * as boardApi from &quot;@/services/board/api&quot;;&#10;&#10;const QuestionDetailPage = () =&gt; {&#10;  const router = useRouter();&#10;  const params = useParams();&#10;  const boardId = Array.isArray(params?.id) ? params.id[0] : params?.id;&#10;&#10;  const { question, loading: questionLoading } = useQuestionDetail(&#10;    boardId as string,&#10;  );&#10;  const { comments, loading: commentsLoading, refetch: refetchComments } = useQuestionComments(&#10;    boardId as string,&#10;    { page: 0, size: 10 },&#10;  );&#10;&#10;  const [comment, setComment] = React.useState(&quot;&quot;);&#10;  const [submitting, setSubmitting] = React.useState(false);&#10;  const [replyingTo, setReplyingTo] = React.useState&lt;string | null&gt;(null);&#10;  const [replyContent, setReplyContent] = React.useState(&quot;&quot;);&#10;&#10;  const handleReportClick = () =&gt; {&#10;    router.push(`/question/${boardId}/report`);&#10;  };&#10;&#10;  const handleReplyClick = (commentId: string) =&gt; {&#10;    setReplyingTo(replyingTo === commentId ? null : commentId);&#10;    setReplyContent(&quot;&quot;);&#10;  };&#10;&#10;  const handleCommentSubmit = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (!comment.trim()) return;&#10;&#10;    try {&#10;      setSubmitting(true);&#10;      await boardApi.createComment({&#10;        boardId: boardId as string,&#10;        content: comment,&#10;      });&#10;      setComment(&quot;&quot;);&#10;      await refetchComments();&#10;    } catch (error) {&#10;    } finally {&#10;      setSubmitting(false);&#10;    }&#10;  };&#10;&#10;  const handleReplySubmit = async (&#10;    e: React.FormEvent,&#10;    parentCommentId: string,&#10;  ) =&gt; {&#10;    e.preventDefault();&#10;    if (!replyContent.trim()) return;&#10;&#10;    try {&#10;      setSubmitting(true);&#10;      await boardApi.createComment({&#10;        boardId: boardId as string,&#10;        content: replyContent,&#10;        parentId: parentCommentId,&#10;      });&#10;      setReplyContent(&quot;&quot;);&#10;      setReplyingTo(null);&#10;      await refetchComments();&#10;    } catch (error) {&#10;    } finally {&#10;      setSubmitting(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;StyledPage&gt;&#10;      &lt;Header types=&quot;report and close&quot; text=&quot;&quot; onClose={handleReportClick} /&gt;&#10;      &lt;Container&gt;&#10;        {questionLoading ? (&#10;          &lt;LoadingSection&gt;로딩 중...&lt;/LoadingSection&gt;&#10;        ) : question ? (&#10;          &lt;&gt;&#10;            &lt;Section&gt;&#10;              &lt;Title&gt;{question.title}&lt;/Title&gt;&#10;              &lt;MetaInfo&gt;&#10;                &lt;MetaItem&gt;{question.author?.name || &quot;작성자 미상&quot;}&lt;/MetaItem&gt;&#10;                &lt;MetaItem&gt;&#10;                  {new Date(question.createdAt).toLocaleString(&quot;ko-KR&quot;)}&#10;                &lt;/MetaItem&gt;&#10;                &lt;BookmarkBox&gt;&#10;                  &lt;BookmarkText&gt;{question.likes}&lt;/BookmarkText&gt;&#10;                &lt;/BookmarkBox&gt;&#10;              &lt;/MetaInfo&gt;&#10;            &lt;/Section&gt;&#10;&#10;            &lt;Divider /&gt;&#10;&#10;            &lt;ContentSection&gt;&#10;              &lt;Content&gt;{question.content}&lt;/Content&gt;&#10;            &lt;/ContentSection&gt;&#10;          &lt;/&gt;&#10;        ) : (&#10;          &lt;ErrorSection&gt;질문을 찾을 수 없습니다.&lt;/ErrorSection&gt;&#10;        )}&#10;&#10;        &lt;Divider /&gt;&#10;&#10;        &lt;CommentsSection&gt;&#10;          &lt;CommentCount&gt;댓글 {comments?.totalElements || 0}&lt;/CommentCount&gt;&#10;          {commentsLoading ? (&#10;            &lt;LoadingText&gt;댓글 로딩 중...&lt;/LoadingText&gt;&#10;          ) : comments?.content &amp;&amp; comments.content.length &gt; 0 ? (&#10;            comments.content.map((comment) =&gt; (&#10;              &lt;React.Fragment key={comment.id}&gt;&#10;                &lt;CommentItemWrapper isReply={false}&gt;&#10;                  &lt;CommentBox&gt;&#10;                    &lt;CommentHeader&gt;&#10;                      &lt;AuthorName&gt;&#10;                        {comment.author?.name || &quot;작성자 미상&quot;}&#10;                      &lt;/AuthorName&gt;&#10;                    &lt;/CommentHeader&gt;&#10;                    &lt;CommentContent&gt;{comment.content}&lt;/CommentContent&gt;&#10;                    &lt;CommentFooter&gt;&#10;                      &lt;FooterItem&gt;&#10;                        {new Date(comment.createdAt).toLocaleString(&quot;ko-KR&quot;)}&#10;                      &lt;/FooterItem&gt;&#10;                      &lt;FooterReportItem&#10;                        onClick={() =&gt;&#10;                          router.push(&#10;                            `/question/${boardId}/comment-report?commentId=${comment.id}`,&#10;                          )&#10;                        }&#10;                      &gt;&#10;                        신고하기&#10;                      &lt;/FooterReportItem&gt;&#10;                      &lt;FooterItem onClick={() =&gt; handleReplyClick(comment.id)}&gt;&#10;                        답글쓰기&#10;                      &lt;/FooterItem&gt;&#10;                    &lt;/CommentFooter&gt;&#10;                  &lt;/CommentBox&gt;&#10;                &lt;/CommentItemWrapper&gt;&#10;&#10;                {replyingTo === comment.id &amp;&amp; (&#10;                  &lt;ReplyInputWrapper&gt;&#10;                    &lt;ReplyInputBox&gt;&#10;                      &lt;ReplyInputField&#10;                        placeholder=&quot;답글을 입력해주세요&quot;&#10;                        value={replyContent}&#10;                        onChange={(e) =&gt; setReplyContent(e.target.value)}&#10;                      /&gt;&#10;                      &lt;ReplySubmitButton&#10;                        onClick={(e) =&gt; handleReplySubmit(e, comment.id)}&#10;                        disabled={submitting}&#10;                      &gt;&#10;                        등록&#10;                      &lt;/ReplySubmitButton&gt;&#10;                    &lt;/ReplyInputBox&gt;&#10;                  &lt;/ReplyInputWrapper&gt;&#10;                )}&#10;&#10;                {comment.replies &amp;&amp;&#10;                  comment.replies.length &gt; 0 &amp;&amp;&#10;                  comment.replies.map((reply) =&gt; (&#10;                    &lt;CommentItemWrapper key={reply.id} isReply={true}&gt;&#10;                      &lt;CommentBox&gt;&#10;                        &lt;CommentHeader&gt;&#10;                          &lt;AuthorName&gt;&#10;                            {reply.author?.name || &quot;작성자 미상&quot;}&#10;                          &lt;/AuthorName&gt;&#10;                        &lt;/CommentHeader&gt;&#10;                        &lt;CommentContent&gt;{reply.content}&lt;/CommentContent&gt;&#10;                        &lt;CommentFooter&gt;&#10;                          &lt;FooterItem&gt;&#10;                            {new Date(reply.createdAt).toLocaleString(&quot;ko-KR&quot;)}&#10;                          &lt;/FooterItem&gt;&#10;                          &lt;FooterReportItem&#10;                            onClick={() =&gt;&#10;                              router.push(&#10;                                `/question/${boardId}/comment-report?commentId=${reply.id}`,&#10;                              )&#10;                            }&#10;                          &gt;&#10;                            신고하기&#10;                          &lt;/FooterReportItem&gt;&#10;                        &lt;/CommentFooter&gt;&#10;                      &lt;/CommentBox&gt;&#10;                    &lt;/CommentItemWrapper&gt;&#10;                  ))}&#10;              &lt;/React.Fragment&gt;&#10;            ))&#10;          ) : (&#10;            &lt;NoCommentText&gt;댓글이 없습니다.&lt;/NoCommentText&gt;&#10;          )}&#10;&#10;          &lt;CommentInputBox&gt;&#10;            &lt;CommentInputField&#10;              placeholder=&quot;댓글을 입력해주세요&quot;&#10;              value={comment}&#10;              onChange={(e) =&gt; setComment(e.target.value)}&#10;            /&gt;&#10;            &lt;CommentSubmitButton&#10;              onClick={handleCommentSubmit}&#10;              disabled={submitting}&#10;            &gt;&#10;              등록&#10;            &lt;/CommentSubmitButton&gt;&#10;          &lt;/CommentInputBox&gt;&#10;        &lt;/CommentsSection&gt;&#10;      &lt;/Container&gt;&#10;&#10;      &lt;NavigationBar /&gt;&#10;    &lt;/StyledPage&gt;&#10;  );&#10;};&#10;&#10;export default QuestionDetailPage;&#10;&#10;const StyledPage = styled.div`&#10;  width: 100%;&#10;  max-width: 600px;&#10;  margin: 0 auto;&#10;  background-color: ${color.white};&#10;  min-height: 100vh;&#10;  padding-top: 80px;&#10;  padding-bottom: 80px;&#10;  display: flex;&#10;  flex-direction: column;&#10;  position: relative;&#10;`;&#10;&#10;const Container = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  width: 100%;&#10;  flex: 1;&#10;`;&#10;&#10;const Section = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;  padding: 20px;&#10;`;&#10;&#10;const Title = styled.h1`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 22px;&#10;  font-weight: 700;&#10;  color: ${color.black};&#10;  line-height: 1;&#10;  margin: 0;&#10;  word-break: break-word;&#10;`;&#10;&#10;const MetaInfo = styled.div`&#10;  display: flex;&#10;  gap: 6px;&#10;  align-items: center;&#10;  flex-wrap: wrap;&#10;`;&#10;&#10;const MetaItem = styled.span`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.gray600};&#10;  white-space: nowrap;&#10;&#10;  &amp;:not(:last-child)::after {&#10;    content: &quot;&quot;;&#10;    width: 1px;&#10;    height: 10px;&#10;    background-color: ${color.gray600};&#10;    margin-left: 6px;&#10;  }&#10;`;&#10;&#10;const BookmarkBox = styled.div`&#10;  display: flex;&#10;  gap: 2px;&#10;  align-items: center;&#10;  margin-left: 6px;&#10;`;&#10;&#10;const BookmarkText = styled.span`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.gray600};&#10;`;&#10;&#10;const Divider = styled.div`&#10;  height: 1px;&#10;  background-color: ${color.gray200};&#10;  width: 100%;&#10;`;&#10;&#10;const ContentSection = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;  padding: 20px;&#10;`;&#10;&#10;const Content = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 400;&#10;  color: ${color.gray700};&#10;  line-height: 24px;&#10;  margin: 0;&#10;  word-break: break-word;&#10;  white-space: pre-wrap;&#10;`;&#10;&#10;const CommentsSection = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  width: 100%;&#10;`;&#10;&#10;const CommentCount = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.gray600};&#10;  line-height: 1;&#10;  margin: 0;&#10;  padding: 20px;&#10;  padding-bottom: 0;&#10;`;&#10;&#10;const CommentItemWrapper = styled.div&lt;{ isReply?: boolean }&gt;`&#10;  display: flex;&#10;  gap: 10px;&#10;  padding: 20px;&#10;  padding-left: ${(props) =&gt; (props.isReply ? &quot;50px&quot; : &quot;20px&quot;)};&#10;  border-bottom: 1px solid ${color.gray100};&#10;`;&#10;&#10;const CommentBox = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;  flex: 1;&#10;  padding: 20px;&#10;`;&#10;&#10;const CommentHeader = styled.div`&#10;  display: flex;&#10;  gap: 6px;&#10;  align-items: center;&#10;`;&#10;&#10;const AuthorName = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.black};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const CommentContent = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${color.black};&#10;  line-height: 1;&#10;  margin: 0;&#10;  word-break: break-word;&#10;  white-space: normal;&#10;`;&#10;&#10;const CommentFooter = styled.div`&#10;  display: flex;&#10;  gap: 6px;&#10;  align-items: center;&#10;  justify-content: space-between;&#10;`;&#10;&#10;const FooterItem = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 10px;&#10;  font-weight: 400;&#10;  color: ${color.gray300};&#10;  line-height: 1;&#10;  margin: 0;&#10;  white-space: nowrap;&#10;&#10;  &amp;:not(:last-child)::after {&#10;    content: &quot;&quot;;&#10;    width: 1px;&#10;    height: 10px;&#10;    background-color: ${color.gray300};&#10;    margin-left: 6px;&#10;  }&#10;`;&#10;&#10;const SubmitButtonContainer = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  margin-left: auto;&#10;`;&#10;&#10;const SubmitButton = styled.button`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 12px;&#10;  font-weight: 400;&#10;  color: ${color.primary};&#10;  background: none;&#10;  border: none;&#10;  cursor: pointer;&#10;  padding: 0;&#10;`;&#10;&#10;const CommentInputBox = styled.div`&#10;  display: flex;&#10;  gap: 10px;&#10;  align-items: center;&#10;  padding: 20px;&#10;  border-top: 1px solid ${color.gray100};&#10;`;&#10;&#10;const CommentInputField = styled.textarea`&#10;  flex: 1;&#10;  background: none;&#10;  border: none;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 13px;&#10;  font-weight: 400;&#10;  color: ${color.black};&#10;  outline: none;&#10;  resize: none;&#10;  min-height: 40px;&#10;&#10;  &amp;::placeholder {&#10;    color: ${color.gray500};&#10;  }&#10;`;&#10;&#10;const FooterReportItem = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 10px;&#10;  font-weight: 400;&#10;  color: ${color.primary};&#10;  line-height: 1;&#10;  margin: 0;&#10;  white-space: nowrap;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.8;&#10;  }&#10;&#10;  &amp;::before {&#10;    content: &quot;&quot;;&#10;    width: 1px;&#10;    height: 10px;&#10;    background-color: ${color.gray300};&#10;    margin-right: 6px;&#10;    display: inline-block;&#10;  }&#10;&#10;  &amp;::after {&#10;    content: &quot;&quot;;&#10;    width: 1px;&#10;    height: 10px;&#10;    background-color: ${color.gray300};&#10;    margin-left: 6px;&#10;    display: inline-block;&#10;  }&#10;`;&#10;&#10;const ModalOverlay = styled.div`&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background-color: rgba(0, 0, 0, 0.5);&#10;  z-index: 999;&#10;`;&#10;&#10;const ModalContainer = styled.div`&#10;  position: fixed;&#10;  top: 50%;&#10;  left: 50%;&#10;  transform: translate(-50%, -50%);&#10;  z-index: 1000;&#10;  max-height: 90vh;&#10;  overflow-y: auto;&#10;  width: 90vw;&#10;  max-width: 400px;&#10;`;&#10;&#10;const ModalContent = styled.div`&#10;  background-color: ${color.white};&#10;  border: 1px solid ${color.gray200};&#10;  border-radius: 24px;&#10;  padding: 32px;&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 32px;&#10;`;&#10;&#10;const ModalTextContainer = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;`;&#10;&#10;const ModalSubtitle = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.gray700};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const ModalTitle = styled.h2`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 22px;&#10;  font-weight: 700;&#10;  color: ${color.black};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const ModalReasonSection = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;`;&#10;&#10;const ModalDetailSection = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;`;&#10;&#10;const LabelWithRequired = styled.div`&#10;  display: flex;&#10;  gap: 4px;&#10;  align-items: center;&#10;`;&#10;&#10;const Label = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${color.gray700};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const RequiredMark = styled.span`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: #e71d36;&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const ReasonList = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 8px;&#10;`;&#10;&#10;const ReasonButton = styled.button&lt;{ isSelected: boolean }&gt;`&#10;  border: 1px solid&#10;    ${(props) =&gt; (props.isSelected ? color.primary : color.gray100)};&#10;  border-radius: 16px;&#10;  padding: 19px 20px;&#10;  background-color: ${(props) =&gt;&#10;    props.isSelected ? color.primary : color.white};&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${(props) =&gt; (props.isSelected ? color.white : color.gray600)};&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;  text-align: left;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.8;&#10;  }&#10;`;&#10;&#10;const DetailTextarea = styled.textarea`&#10;  border: 1px solid ${color.gray100};&#10;  border-radius: 16px;&#10;  padding: 20px;&#10;  min-height: 120px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 12px;&#10;  font-weight: 400;&#10;  color: ${color.black};&#10;  background-color: ${color.white};&#10;  resize: none;&#10;  outline: none;&#10;&#10;  &amp;::placeholder {&#10;    color: ${color.gray300};&#10;  }&#10;`;&#10;&#10;const CharCount = styled.p`&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 13px;&#10;  font-weight: 400;&#10;  color: ${color.gray300};&#10;  line-height: 1;&#10;  margin: 0;&#10;`;&#10;&#10;const ModalButtonContainer = styled.div`&#10;  display: flex;&#10;  gap: 12px;&#10;  align-items: center;&#10;  justify-content: center;&#10;  width: 100%;&#10;`;&#10;&#10;const ModalCancelButton = styled.button`&#10;  flex: 1;&#10;  background-color: ${color.white};&#10;  border: 1px solid ${color.gray100};&#10;  border-radius: 100px;&#10;  padding: 12px 20px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${color.black};&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.8;&#10;  }&#10;`;&#10;&#10;const ModalConfirmButton = styled.button`&#10;  flex: 1;&#10;  background-color: ${(props) =&gt;&#10;    props.disabled ? color.gray200 : color.primary};&#10;  border: none;&#10;  border-radius: 100px;&#10;  padding: 12px 20px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  color: ${color.white};&#10;  cursor: ${(props) =&gt; (props.disabled ? &quot;not-allowed&quot; : &quot;pointer&quot;)};&#10;  transition: all 0.2s ease;&#10;`;&#10;&#10;const LoadingText = styled.p`&#10;  text-align: center;&#10;  font-size: 14px;&#10;  color: ${color.gray600};&#10;  padding: 20px;&#10;  margin: 0;&#10;`;&#10;&#10;const NoCommentText = styled.p`&#10;  text-align: center;&#10;  font-size: 14px;&#10;  color: ${color.gray600};&#10;  padding: 40px 20px;&#10;  margin: 0;&#10;`;&#10;&#10;const CommentSubmitButton = styled.button`&#10;  background-color: ${(props) =&gt;&#10;    props.disabled ? color.gray200 : color.primary};&#10;  border: none;&#10;  border-radius: 6px;&#10;  padding: 10px 16px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 600;&#10;  color: ${color.white};&#10;  cursor: ${(props) =&gt; (props.disabled ? &quot;not-allowed&quot; : &quot;pointer&quot;)};&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.9;&#10;  }&#10;`;&#10;&#10;const LoadingSection = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  padding: 40px 20px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  color: ${color.gray600};&#10;`;&#10;&#10;const ErrorSection = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  padding: 40px 20px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  color: ${color.gray600};&#10;`;&#10;&#10;const ReplyInputWrapper = styled.div`&#10;  padding: 0 20px 16px 40px;&#10;`;&#10;&#10;const ReplyInputBox = styled.div`&#10;  display: flex;&#10;  gap: 8px;&#10;  width: 100%;&#10;`;&#10;&#10;const ReplyInputField = styled.input`&#10;  flex: 1;&#10;  border: 1px solid ${color.gray200};&#10;  border-radius: 6px;&#10;  padding: 10px 12px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 400;&#10;  color: ${color.black};&#10;  background-color: ${color.white};&#10;  outline: none;&#10;&#10;  &amp;::placeholder {&#10;    color: ${color.gray300};&#10;  }&#10;&#10;  &amp;:focus {&#10;    border-color: ${color.primary};&#10;  }&#10;`;&#10;&#10;const ReplySubmitButton = styled.button`&#10;  background-color: ${(props) =&gt;&#10;    props.disabled ? color.gray200 : color.primary};&#10;  border: none;&#10;  border-radius: 6px;&#10;  padding: 10px 16px;&#10;  font-family: Pretendard, sans-serif;&#10;  font-size: 14px;&#10;  font-weight: 600;&#10;  color: ${color.white};&#10;  cursor: ${(props) =&gt; (props.disabled ? &quot;not-allowed&quot; : &quot;pointer&quot;)};&#10;  transition: all 0.2s ease;&#10;  white-space: nowrap;&#10;&#10;  &amp;:hover {&#10;    opacity: 0.9;&#10;  }&#10;`;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/token-initializer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/token-initializer.tsx" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { useEffect } from &quot;react&quot;;&#10;import { TOKEN } from &quot;@/constants/common/constant&quot;;&#10;import { Storage } from &quot;@/apis/storage/storage&quot;;&#10;&#10;export default function TokenInitializer() {&#10;  useEffect(() =&gt; {&#10;    const getCookie = (name: string) =&gt; {&#10;      if (typeof document === &quot;undefined&quot;) return null;&#10;      const value = `; ${document.cookie}`;&#10;      const parts = value.split(`; ${name}=`);&#10;      if (parts.length === 2) return parts.pop()?.split(&quot;;&quot;).shift();&#10;      return null;&#10;    };&#10;&#10;    const clearCookie = (name: string) =&gt; {&#10;      if (typeof document === &quot;undefined&quot;) return;&#10;      document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;&#10;    };&#10;&#10;    try {&#10;      const accessToken = getCookie(&quot;accessToken&quot;);&#10;      const refreshToken = getCookie(&quot;refreshToken&quot;);&#10;&#10;      console.log(&quot;Token Initializer - Found Access Token:&quot;, !!accessToken);&#10;      console.log(&quot;Token Initializer - Found Refresh Token:&quot;, !!refreshToken);&#10;&#10;      if (accessToken) {&#10;        console.log(&quot;Saving access token to localStorage&quot;);&#10;        Storage.setItem(TOKEN.ACCESS, accessToken);&#10;        clearCookie(&quot;accessToken&quot;);&#10;      }&#10;&#10;      if (refreshToken) {&#10;        console.log(&quot;Saving refresh token to localStorage&quot;);&#10;        Storage.setItem(TOKEN.REFRESH, refreshToken);&#10;        clearCookie(&quot;refreshToken&quot;);&#10;      }&#10;&#10;      if (accessToken || refreshToken) {&#10;        console.log(&quot;Tokens saved successfully&quot;);&#10;        console.log(&quot;Access Token in storage:&quot;, Storage.getItem(TOKEN.ACCESS) ? &quot;✓&quot; : &quot;✗&quot;);&#10;        console.log(&quot;Refresh Token in storage:&quot;, Storage.getItem(TOKEN.REFRESH) ? &quot;✓&quot; : &quot;✗&quot;);&#10;      }&#10;    } catch (error) {&#10;      console.error(&quot;Error in TokenInitializer:&quot;, error);&#10;    }&#10;  }, []);&#10;&#10;  return null;&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/board/api.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/board/api.ts" />
              <option name="originalContent" value="import { upik } from &quot;@/apis&quot;;&#10;import type {&#10;  Board,&#10;  CommentPage,&#10;  Comment,&#10;  CreateQuestionInput,&#10;  UpdateQuestionInput,&#10;  CreateCommentInput,&#10;  PageResponse,&#10;  PaginationParams,&#10;} from &quot;@/types/graphql&quot;;&#10;import {&#10;  GET_QUESTION_LIST,&#10;  GET_QUESTION_DETAIL,&#10;  GET_COMMENTS,&#10;  SEARCH_QUESTIONS,&#10;} from &quot;./queries&quot;;&#10;import {&#10;  CREATE_QUESTION,&#10;  UPDATE_QUESTION,&#10;  DELETE_QUESTION,&#10;  CREATE_COMMENT,&#10;  REPORT_BOARD,&#10;  REPORT_COMMENT,&#10;} from &quot;./mutations&quot;;&#10;import { Storage } from &quot;@/apis/storage/storage&quot;;&#10;import { TOKEN } from &quot;@/constants/common/constant&quot;;&#10;import { API } from &quot;@/constants/upik&quot;;&#10;&#10;interface GraphQLRequest {&#10;  query: string;&#10;  variables?: Record&lt;string, unknown&gt;;&#10;}&#10;&#10;export async function getQuestionList(&#10;  pagination: PaginationParams,&#10;): Promise&lt;PageResponse&lt;Board&gt;&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: GET_QUESTION_LIST,&#10;      variables: { page: pagination.page, size: pagination.size },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const questions = response.data?.data?.board?.getQuestionList?.content || [];&#10;  const totalPages =&#10;    response.data?.data?.board?.getQuestionList?.totalPages || 1;&#10;  const totalElements =&#10;    response.data?.data?.board?.getQuestionList?.totalElements ||&#10;    questions.length;&#10;&#10;  const data: PageResponse&lt;Board&gt; = {&#10;    content: questions.map((q: any) =&gt; ({&#10;      id: q.id,&#10;      title: q.title,&#10;      content: q.content,&#10;      createdAt: q.createdAt,&#10;      updatedAt: q.updatedAt,&#10;      author: {&#10;        id: q.userId,&#10;        name: q.userName,&#10;        avatar: q.userProfileImage,&#10;      },&#10;      views: q.viewCount || 0,&#10;      likes: 0,&#10;      commentCount: q.commentCount || 0,&#10;      status: &quot;OPEN&quot;,&#10;      isBookmarked: q.isBookmarked,&#10;      bookmarkCount: q.bookmarkCount || 0,&#10;    })) as any[],&#10;    totalPages: totalPages,&#10;    totalElements: totalElements,&#10;    currentPage: pagination.page,&#10;    pageSize: pagination.size,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function getQuestionDetail(boardId: string): Promise&lt;Board&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: GET_QUESTION_DETAIL,&#10;      variables: { boardId },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const question = response.data?.data?.board?.getQuestionDetail;&#10;  if (!question) {&#10;    throw new Error(&quot;Question not found&quot;);&#10;  }&#10;&#10;  const data: Board = {&#10;    id: question.id,&#10;    title: question.title,&#10;    content: question.content || &quot;&quot;,&#10;    createdAt: question.createdAt || new Date().toISOString(),&#10;    updatedAt: question.updatedAt,&#10;    author: {&#10;      id: question.userId,&#10;      name: question.userName,&#10;      avatar: question.userProfileImage,&#10;    },&#10;    views: question.viewCount || 0,&#10;    commentCount: question.commentCount || 0,&#10;    likes: 0,&#10;    status: &quot;OPEN&quot;,&#10;    isBookmarked: question.isBookmarked,&#10;    bookmarkCount: question.bookmarkCount || 0,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function getComments(&#10;  boardId: string,&#10;  pagination: PaginationParams,&#10;): Promise&lt;CommentPage&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: GET_COMMENTS,&#10;      variables: { boardId, page: pagination.page, size: pagination.size },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const comments = response.data?.data?.board?.getComments?.content || [];&#10;  const totalPages = response.data?.data?.board?.getComments?.totalPages || 1;&#10;  const totalElements =&#10;    response.data?.data?.board?.getComments?.totalElements || comments.length;&#10;&#10;  const mapComment = (c: any): Comment =&gt; ({&#10;    id: c.id,&#10;    content: c.content,&#10;    createdAt: c.createdAt,&#10;    updatedAt: c.updatedAt,&#10;    userId: c.userId,&#10;    userName: c.userName,&#10;    userProfileImage: c.userProfileImage,&#10;    boardId: c.boardId,&#10;    parentId: c.parentId,&#10;    author: {&#10;      id: c.userId,&#10;      name: c.userName,&#10;      avatar: c.userProfileImage,&#10;    },&#10;    replies:&#10;      c.replies &amp;&amp; c.replies.length &gt; 0 ? c.replies.map(mapComment) : undefined,&#10;    likes: 0,&#10;  });&#10;&#10;  const data: CommentPage = {&#10;    content: comments.map(mapComment),&#10;    totalPages: totalPages,&#10;    totalElements: totalElements,&#10;    currentPage: pagination.page,&#10;    pageSize: pagination.size,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function searchQuestions(&#10;  keyword: string,&#10;  pagination: PaginationParams,&#10;): Promise&lt;PageResponse&lt;Board&gt;&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: SEARCH_QUESTIONS,&#10;      variables: { keyword, page: pagination.page, size: pagination.size },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const data = response.data?.data?.board?.searchQuestions;&#10;  if (!data) {&#10;    throw new Error(&quot;Failed to search questions&quot;);&#10;  }&#10;  return data;&#10;}&#10;&#10;export async function createQuestion(&#10;  input: CreateQuestionInput,&#10;): Promise&lt;Board&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: CREATE_QUESTION,&#10;      variables: { input },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const question = response.data?.data?.board?.createQuestion;&#10;  if (!question) {&#10;    throw new Error(&quot;Failed to create question&quot;);&#10;  }&#10;&#10;  const data: Board = {&#10;    id: question.id,&#10;    title: question.title,&#10;    content: question.content,&#10;    createdAt: question.createdAt,&#10;    updatedAt: question.updatedAt,&#10;    author: {&#10;      id: question.userId,&#10;      name: question.userName,&#10;      avatar: question.userProfileImage,&#10;    },&#10;    views: question.viewCount || 0,&#10;    likes: 0,&#10;    commentCount: question.commentCount || 0,&#10;    status: &quot;OPEN&quot;,&#10;    isBookmarked: question.isBookmarked || false,&#10;    bookmarkCount: question.bookmarkCount || 0,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function updateQuestion(&#10;  boardId: string,&#10;  input: UpdateQuestionInput,&#10;): Promise&lt;Board&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: UPDATE_QUESTION,&#10;      variables: { boardId, input },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const question = response.data?.data?.board?.updateQuestion;&#10;  if (!question) {&#10;    throw new Error(&quot;Failed to update question&quot;);&#10;  }&#10;&#10;  const data: Board = {&#10;    id: question.id,&#10;    title: question.title,&#10;    content: question.content,&#10;    createdAt: question.createdAt,&#10;    updatedAt: question.updatedAt,&#10;    author: {&#10;      id: question.userId,&#10;      name: question.userName,&#10;      avatar: question.userProfileImage,&#10;    },&#10;    views: question.viewCount || 0,&#10;    likes: 0,&#10;    commentCount: question.commentCount || 0,&#10;    status: &quot;OPEN&quot;,&#10;    isBookmarked: question.isBookmarked || false,&#10;    bookmarkCount: question.bookmarkCount || 0,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function deleteQuestion(boardId: string): Promise&lt;boolean&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: DELETE_QUESTION,&#10;      variables: { boardId },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const result = response.data?.data?.board?.deleteQuestion;&#10;  if (!result) {&#10;    throw new Error(&quot;Failed to delete question&quot;);&#10;  }&#10;  return true;&#10;}&#10;&#10;export async function createComment(&#10;  input: CreateCommentInput,&#10;): Promise&lt;Comment&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: CREATE_COMMENT,&#10;      variables: { input },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const comment = response.data?.data?.board?.createComment;&#10;  if (!comment) {&#10;    throw new Error(&quot;Failed to create comment&quot;);&#10;  }&#10;&#10;  const mapComment = (c: any): Comment =&gt; ({&#10;    id: c.id,&#10;    content: c.content,&#10;    createdAt: c.createdAt,&#10;    updatedAt: c.updatedAt,&#10;    userId: c.userId,&#10;    userName: c.userName,&#10;    userProfileImage: c.userProfileImage,&#10;    boardId: c.boardId,&#10;    parentId: c.parentId,&#10;    author: {&#10;      id: c.userId,&#10;      name: c.userName,&#10;      avatar: c.userProfileImage,&#10;    },&#10;    likes: 0,&#10;    replies: c.replies?.map(mapComment) || [],&#10;  });&#10;&#10;  return mapComment(comment);&#10;}&#10;&#10;export async function reportBoard(&#10;  boardId: string,&#10;  reason: string,&#10;  detail: string,&#10;): Promise&lt;boolean&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: REPORT_BOARD,&#10;      variables: { boardId, reason, detail },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const result = response.data?.data?.board?.reportBoard;&#10;  if (!result) {&#10;    throw new Error(&quot;Failed to report question&quot;);&#10;  }&#10;  return true;&#10;}&#10;&#10;export async function reportComment(&#10;  commentId: string,&#10;  reason: string,&#10;  detail: string,&#10;): Promise&lt;boolean&gt; {&#10;  const token = Storage.getItem(TOKEN.ACCESS);&#10;  const response = await upik.post(&#10;    API.GRAPHQL_URL,&#10;    {&#10;      query: REPORT_COMMENT,&#10;      variables: { commentId, reason, detail },&#10;    } as GraphQLRequest,&#10;    {&#10;      headers: {&#10;        Authorization: `Bearer ${token}`,&#10;      },&#10;    },&#10;  );&#10;&#10;  const result = response.data?.data?.board?.reportComment;&#10;  if (!result) {&#10;    throw new Error(&quot;Failed to report comment&quot;);&#10;  }&#10;  return true;&#10;}&#10;" />
              <option name="updatedContent" value="import { upik } from &quot;@/apis&quot;;&#10;import type {&#10;  Board,&#10;  CommentPage,&#10;  Comment,&#10;  CreateQuestionInput,&#10;  UpdateQuestionInput,&#10;  CreateCommentInput,&#10;  PageResponse,&#10;  PaginationParams,&#10;} from &quot;@/types/graphql&quot;;&#10;import {&#10;  GET_QUESTION_LIST,&#10;  GET_QUESTION_DETAIL,&#10;  GET_COMMENTS,&#10;  SEARCH_QUESTIONS,&#10;} from &quot;./queries&quot;;&#10;import {&#10;  CREATE_QUESTION,&#10;  UPDATE_QUESTION,&#10;  DELETE_QUESTION,&#10;  CREATE_COMMENT,&#10;  REPORT_BOARD,&#10;  REPORT_COMMENT,&#10;} from &quot;./mutations&quot;;&#10;import { API } from &quot;@/constants/upik&quot;;&#10;&#10;interface GraphQLRequest {&#10;  query: string;&#10;  variables?: Record&lt;string, unknown&gt;;&#10;}&#10;&#10;export async function getQuestionList(&#10;  pagination: PaginationParams,&#10;): Promise&lt;PageResponse&lt;Board&gt;&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: GET_QUESTION_LIST,&#10;    variables: { page: pagination.page, size: pagination.size },&#10;  } as GraphQLRequest);&#10;&#10;  const questions = response.data?.data?.board?.getQuestionList?.content || [];&#10;  const totalPages =&#10;    response.data?.data?.board?.getQuestionList?.totalPages || 1;&#10;  const totalElements =&#10;    response.data?.data?.board?.getQuestionList?.totalElements ||&#10;    questions.length;&#10;&#10;  const data: PageResponse&lt;Board&gt; = {&#10;    content: questions.map((q: any) =&gt; ({&#10;      id: q.id,&#10;      title: q.title,&#10;      content: q.content,&#10;      createdAt: q.createdAt,&#10;      updatedAt: q.updatedAt,&#10;      author: {&#10;        id: q.userId,&#10;        name: q.userName,&#10;        avatar: q.userProfileImage,&#10;      },&#10;      views: q.viewCount || 0,&#10;      likes: 0,&#10;      commentCount: q.commentCount || 0,&#10;      status: &quot;OPEN&quot;,&#10;      isBookmarked: q.isBookmarked,&#10;      bookmarkCount: q.bookmarkCount || 0,&#10;    })) as any[],&#10;    totalPages: totalPages,&#10;    totalElements: totalElements,&#10;    currentPage: pagination.page,&#10;    pageSize: pagination.size,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function getQuestionDetail(boardId: string): Promise&lt;Board&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: GET_QUESTION_DETAIL,&#10;    variables: { boardId },&#10;  } as GraphQLRequest);&#10;&#10;  const question = response.data?.data?.board?.getQuestionDetail;&#10;  if (!question) {&#10;    throw new Error(&quot;Question not found&quot;);&#10;  }&#10;&#10;  const data: Board = {&#10;    id: question.id,&#10;    title: question.title,&#10;    content: question.content || &quot;&quot;,&#10;    createdAt: question.createdAt || new Date().toISOString(),&#10;    updatedAt: question.updatedAt,&#10;    author: {&#10;      id: question.userId,&#10;      name: question.userName,&#10;      avatar: question.userProfileImage,&#10;    },&#10;    views: question.viewCount || 0,&#10;    commentCount: question.commentCount || 0,&#10;    likes: 0,&#10;    status: &quot;OPEN&quot;,&#10;    isBookmarked: question.isBookmarked,&#10;    bookmarkCount: question.bookmarkCount || 0,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function getComments(&#10;  boardId: string,&#10;  pagination: PaginationParams,&#10;): Promise&lt;CommentPage&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: GET_COMMENTS,&#10;    variables: { boardId, page: pagination.page, size: pagination.size },&#10;  } as GraphQLRequest);&#10;&#10;  const comments = response.data?.data?.board?.getComments?.content || [];&#10;  const totalPages = response.data?.data?.board?.getComments?.totalPages || 1;&#10;  const totalElements =&#10;    response.data?.data?.board?.getComments?.totalElements || comments.length;&#10;&#10;  const mapComment = (c: any): Comment =&gt; ({&#10;    id: c.id,&#10;    content: c.content,&#10;    createdAt: c.createdAt,&#10;    updatedAt: c.updatedAt,&#10;    userId: c.userId,&#10;    userName: c.userName,&#10;    userProfileImage: c.userProfileImage,&#10;    boardId: c.boardId,&#10;    parentId: c.parentId,&#10;    author: {&#10;      id: c.userId,&#10;      name: c.userName,&#10;      avatar: c.userProfileImage,&#10;    },&#10;    replies:&#10;      c.replies &amp;&amp; c.replies.length &gt; 0 ? c.replies.map(mapComment) : undefined,&#10;    likes: 0,&#10;  });&#10;&#10;  const data: CommentPage = {&#10;    content: comments.map(mapComment),&#10;    totalPages: totalPages,&#10;    totalElements: totalElements,&#10;    currentPage: pagination.page,&#10;    pageSize: pagination.size,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function searchQuestions(&#10;  keyword: string,&#10;  pagination: PaginationParams,&#10;): Promise&lt;PageResponse&lt;Board&gt;&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: SEARCH_QUESTIONS,&#10;    variables: { keyword, page: pagination.page, size: pagination.size },&#10;  } as GraphQLRequest);&#10;&#10;  const data = response.data?.data?.board?.searchQuestions;&#10;  if (!data) {&#10;    throw new Error(&quot;Failed to search questions&quot;);&#10;  }&#10;  return data;&#10;}&#10;&#10;export async function createQuestion(&#10;  input: CreateQuestionInput,&#10;): Promise&lt;Board&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: CREATE_QUESTION,&#10;    variables: { input },&#10;  } as GraphQLRequest);&#10;&#10;  const question = response.data?.data?.board?.createQuestion;&#10;  if (!question) {&#10;    throw new Error(&quot;Failed to create question&quot;);&#10;  }&#10;&#10;  const data: Board = {&#10;    id: question.id,&#10;    title: question.title,&#10;    content: question.content,&#10;    createdAt: question.createdAt,&#10;    updatedAt: question.updatedAt,&#10;    author: {&#10;      id: question.userId,&#10;      name: question.userName,&#10;      avatar: question.userProfileImage,&#10;    },&#10;    views: question.viewCount || 0,&#10;    likes: 0,&#10;    commentCount: question.commentCount || 0,&#10;    status: &quot;OPEN&quot;,&#10;    isBookmarked: question.isBookmarked || false,&#10;    bookmarkCount: question.bookmarkCount || 0,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function updateQuestion(&#10;  boardId: string,&#10;  input: UpdateQuestionInput,&#10;): Promise&lt;Board&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: UPDATE_QUESTION,&#10;    variables: { boardId, input },&#10;  } as GraphQLRequest);&#10;&#10;  const question = response.data?.data?.board?.updateQuestion;&#10;  if (!question) {&#10;    throw new Error(&quot;Failed to update question&quot;);&#10;  }&#10;&#10;  const data: Board = {&#10;    id: question.id,&#10;    title: question.title,&#10;    content: question.content,&#10;    createdAt: question.createdAt,&#10;    updatedAt: question.updatedAt,&#10;    author: {&#10;      id: question.userId,&#10;      name: question.userName,&#10;      avatar: question.userProfileImage,&#10;    },&#10;    views: question.viewCount || 0,&#10;    likes: 0,&#10;    commentCount: question.commentCount || 0,&#10;    status: &quot;OPEN&quot;,&#10;    isBookmarked: question.isBookmarked || false,&#10;    bookmarkCount: question.bookmarkCount || 0,&#10;  };&#10;&#10;  return data;&#10;}&#10;&#10;export async function deleteQuestion(boardId: string): Promise&lt;boolean&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: DELETE_QUESTION,&#10;    variables: { boardId },&#10;  } as GraphQLRequest);&#10;&#10;  const result = response.data?.data?.board?.deleteQuestion;&#10;  if (!result) {&#10;    throw new Error(&quot;Failed to delete question&quot;);&#10;  }&#10;  return true;&#10;}&#10;&#10;export async function createComment(&#10;  input: CreateCommentInput,&#10;): Promise&lt;Comment&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: CREATE_COMMENT,&#10;    variables: { input },&#10;  } as GraphQLRequest);&#10;&#10;  const comment = response.data?.data?.board?.createComment;&#10;  if (!comment) {&#10;    throw new Error(&quot;Failed to create comment&quot;);&#10;  }&#10;&#10;  const mapComment = (c: any): Comment =&gt; ({&#10;    id: c.id,&#10;    content: c.content,&#10;    createdAt: c.createdAt,&#10;    updatedAt: c.updatedAt,&#10;    userId: c.userId,&#10;    userName: c.userName,&#10;    userProfileImage: c.userProfileImage,&#10;    boardId: c.boardId,&#10;    parentId: c.parentId,&#10;    author: {&#10;      id: c.userId,&#10;      name: c.userName,&#10;      avatar: c.userProfileImage,&#10;    },&#10;    likes: 0,&#10;    replies: c.replies?.map(mapComment) || [],&#10;  });&#10;&#10;  return mapComment(comment);&#10;}&#10;&#10;export async function reportBoard(&#10;  boardId: string,&#10;  reason: string,&#10;  detail: string,&#10;): Promise&lt;boolean&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: REPORT_BOARD,&#10;    variables: { boardId, reason, detail },&#10;  } as GraphQLRequest);&#10;&#10;  const result = response.data?.data?.board?.reportBoard;&#10;  if (!result) {&#10;    throw new Error(&quot;Failed to report question&quot;);&#10;  }&#10;  return true;&#10;}&#10;&#10;export async function reportComment(&#10;  commentId: string,&#10;  reason: string,&#10;  detail: string,&#10;): Promise&lt;boolean&gt; {&#10;  const response = await upik.post(API.GRAPHQL_URL, {&#10;    query: REPORT_COMMENT,&#10;    variables: { commentId, reason, detail },&#10;  } as GraphQLRequest);&#10;&#10;  const result = response.data?.data?.board?.reportComment;&#10;  if (!result) {&#10;    throw new Error(&quot;Failed to report comment&quot;);&#10;  }&#10;  return true;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/report/hook.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/report/hook.ts" />
              <option name="originalContent" value="import { useState } from &quot;react&quot;;&#10;import { sendReport, ReportData } from &quot;./api&quot;;&#10;&#10;export interface UseReportReturn {&#10;  isLoading: boolean;&#10;  error: string | null;&#10;  sendReport: (data: ReportData) =&gt; Promise&lt;void&gt;;&#10;}&#10;&#10;export const useReport = (): UseReportReturn =&gt; {&#10;  const [isLoading, setIsLoading] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;  const handleSendReport = async (data: ReportData) =&gt; {&#10;    setIsLoading(true);&#10;    setError(null);&#10;&#10;    try {&#10;      await sendReport(data);&#10;    } catch (err) {&#10;      const errorMessage =&#10;        err instanceof Error ? err.message : &quot;신고 전송에 실패했습니다.&quot;;&#10;      setError(errorMessage);&#10;      throw err;&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  return {&#10;    isLoading,&#10;    error,&#10;    sendReport: handleSendReport,&#10;  };&#10;};&#10;" />
              <option name="updatedContent" value="import { useState } from &quot;react&quot;;&#10;import { reportBoard, reportComment } from &quot;./api&quot;;&#10;import type { ReportBoardData, ReportCommentData } from &quot;./api&quot;;&#10;&#10;export interface UseReportReturn {&#10;  isLoading: boolean;&#10;  error: string | null;&#10;  reportBoard: (data: ReportBoardData) =&gt; Promise&lt;void&gt;;&#10;  reportComment: (data: ReportCommentData) =&gt; Promise&lt;void&gt;;&#10;}&#10;&#10;export const useReport = (): UseReportReturn =&gt; {&#10;  const [isLoading, setIsLoading] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;  const handleReportBoard = async (data: ReportBoardData) =&gt; {&#10;    setIsLoading(true);&#10;    setError(null);&#10;&#10;    try {&#10;      await reportBoard(data);&#10;    } catch (err) {&#10;      const errorMessage =&#10;        err instanceof Error ? err.message : &quot;게시물 신고에 실패했습니다.&quot;;&#10;      setError(errorMessage);&#10;      throw err;&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleReportComment = async (data: ReportCommentData) =&gt; {&#10;    setIsLoading(true);&#10;    setError(null);&#10;&#10;    try {&#10;      await reportComment(data);&#10;    } catch (err) {&#10;      const errorMessage =&#10;        err instanceof Error ? err.message : &quot;댓글 신고에 실패했습니다.&quot;;&#10;      setError(errorMessage);&#10;      throw err;&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  return {&#10;    isLoading,&#10;    error,&#10;    reportBoard: handleReportBoard,&#10;    reportComment: handleReportComment,&#10;  };&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>